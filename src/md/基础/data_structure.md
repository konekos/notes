## ArrayList和LinkedList

2者区别也并不是‘顺序’或‘有序’，而是本身的结构决定的：
Java SE提供的LinkedList其实是一种双向链表，每个节点都保存上一个和下一个节点的地址。
双向链表就像火车和火车的各节车厢。在插入时，把新车厢的前后固定点在原来的2个环的连接点之间简单对接上。而删除时，拿掉一节车厢，直接把前一节和后一节首尾相连。所以仅对连接点操作，效率非常快。只需一次。查找时，就需要从火车头顺序‘逐个’找到车尾，这种逐个检查所以查找效率不佳。

ArrayList使用的是‘连续’(不是有序)的内存空间。每个单元的大小和位置可以用简单的四则运算计算出来，比如每个节点占4bytes，存20个节点，就需要4*20=80bytes，第3个节点在4*3=第12个byte位置。由于可以计算准确位置，这种结构在'随机存取操作'上很快，可以直接查第3个节点，就是第12个byte位置, a[3]或a.get(3)就返回第12byte位置起的数据代表的对象。这种随机操作的便捷就是应用意义上的查找便捷。在新增和删除操作中，由于是连续空间，插入数据需要对前后数据进行大块的整体搬移，空间不够时也需要整体扩容，删除后空间闲置需要整体回收。所以在删除新增操作上性能不佳。

## HashMap

数组 + 链表 + 红黑树（链表长度>8）
1. Node[] table, 哈希桶数组.实现了MapEntry
2. 链地址法。哈希算法：高位运算与取模运算。减少hash碰撞概率，

int threshold;             // 所能容纳的key-value对极限
final float loadFactor;    // 负载因子
int modCount;  
int size;

首先，Node[] table的初始化长度length(默认值是16)，Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。

在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，

这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，

### 1. 确定哈希桶数组索引位置
```
方法一：
static final int hash(Object key) {   //jdk1.8 & jdk1.7
     int h;
     // h = key.hashCode() 为第一步 取hashCode值
     // h ^ (h >>> 16)  为第二步 高位参与运算
     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
方法二：
static int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的
     return h & (length-1);  //第三步 取模运算
}
```

### 2. put

### 3. 扩容


## LinkedHashMap
保持插入顺序。Hash表+链表
