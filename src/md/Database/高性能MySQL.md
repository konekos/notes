# MySQL

## 1、事务

### ACID

1. **原子性** Atomicity ：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。
2. **一致性** Consistency ：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设[约束](https://zh.wikipedia.org/wiki/数据完整性)、[触发器](https://zh.wikipedia.org/wiki/触发器_(数据库))、[级联回滚](https://zh.wikipedia.org/w/index.php?title=级联回滚&action=edit&redlink=1)等。
3. **隔离性** Isolation ：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
4. **持久性** Durability ：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。



### 隔离级别

- READ UNCOMMITTED（未提交读）：事务中的修改，即使没有提交，对其他事务也都是可见的。

  > 会导致脏读。

- READ COMMITTED（提交读）：事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。

  > 会导致不可重复读。
  >
  > 这个隔离级别，也可以叫做“不可重复读”。

- REPEATABLE READ（可重复读）：一个事务按相同的查询条件读取以前检索过的数据，其他事务插入了满足其查询条件的新数据。产生幻行。

  > 会导致幻读。

- SERIALIZABLE（可串行化）：强制事务串行执行。

  

  MySQL InnoDB 采用 **MVCC** 来支持高并发。

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读    |
| ---------------------------- | ---- | ---------- | ------- |
| 读未提交（read-uncommitted） | 是   | 是         | 是      |
| 读已提交（read-committed）   | 否   | 是         | 是      |
| 可重复读（repeatable-read）  | 否   | 否         | 是（x） |
| 串行化（serializable）       | 否   | 否         | 否      |

- MySQL 默认的事务隔离级别为可重复读（repeatable-read） 。
- **MySQL 通过 MVCC + 事务第一次调用 `SELECT` 语句才生成快照，实现其在可重复读（repeatable-read）的隔离级别下，不存在幻读问题。**

### 死锁

InnoDB目前处理事务的方式是回滚持有最少行级排它锁的事务。



### 自动提交 （AUTOCOMMIT）

MySQL自动使用autocommit模式，如果不显式开始事务，每一个查询都被当做一个事务执行提交操作。

### 在事务中混合使用存储引擎

MySQL服务器层不管理事务，由下层储存引擎实现。同一事务使用不同储存引擎不可靠。

### 隐式和显式锁定

InnoDB使用两阶段锁定协议。执行事务时，随时执行锁定，锁只有在commit和rollback时释放。这是隐式锁定，InnoDB根据隔离级别在需要的时候自动加锁。

InnoDB支持特定语句显式锁定，不属于SQL规范。

- SELECT ... LOCK IN SHARE MODE
- SELECT ... FOR UPDATE





## 2、并发控制

读写锁（共享锁和排它锁）

锁粒度：表锁、行锁



MVCC是行级锁的变种，很多情况避免加锁，开销更低。不同的实现机制不同，大都实现非阻塞读，写操作只锁定必要的行。

MVCC实现是由保存数据在某个时间点的快照实现的。不管执行多长时间，每个事务看到的数据一致。

InnoDB的MVCC，通过在每行记录后面保存两个隐藏的列实现。一个保存行创建时间，一个保存行的过期时间（删除时间），存储的是系统版本号（system version number）。每开始一个事务，系统版本号自动递增。事务开始时，系统版本号作为事务版本号，和查询到的每行记录版本号比较。

REPEATABLE READ下，MVCC的具体行为。

- SELECT：查找行的系统版本号要小于等于事务版本号。要么事务开启前存在，要么事务自身修改过。 删除版本号要么未定义，要么大于当前事务版本号。
- INSERT:  保存当前系统版本号为行版本号。
- DELETE：保存当前系统版本号位行删除标志。
- UPDATE：为每个需要更新的行，建立一个新的行拷贝，记录当前版本号为行版本号。为更新前的旧行记录系统版本号为旧行的删除版本标识。



MVCC只在REPEATABLE READ和 READ COMMITTED两个隔离级别工作。 



## MySQL 当前读、快照读、MVCC

### 当前读:

select...lock in share mode (共享读锁)
　　select...for update
　　update , delete , insert

　　当前读, 读取的是最新版本, 并且**对读取的记录加锁, 阻塞其他事务同时改动相同**记录，避免出现安全问题。

　　例如，假设要update一条记录，但是另一个事务已经delete这条数据并且commit了，如果不加锁就会产生冲突。所以update的时候肯定要是当前读，得到最新的信息并且锁定相应的记录。

### 当前读的实现方式：next-key锁(行记录锁+Gap间隙锁)

**间隙锁：**只有在Read Repeatable、Serializable隔离级别才有，就是锁定范围空间的数据，假设id有3,4,5，锁定id>3的数据，是指的4，5及**后面的数字都会被锁定，**因为此时如果不锁定没有的数据，例如当加入了新的数据id=6，就会出现幻读，间隙锁避免了幻读。

1. 对主键或唯一索引，如果当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。

2. 没有索引的列，当前读操作时，会加全表gap锁，生产环境要注意。

3. 非唯一索引列，如果where条件部分命中(>、<、like等)或者全未命中，则会加附近Gap间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据。![img](https://img2018.cnblogs.com/blog/1394267/201904/1394267-20190419210558267-1762386565.png)

###  快照读

　　单纯的select操作，**不包括**上述 select ... lock in share mode, select ... for update。　　　　

　　Read Committed隔离级别：每次select都生成一个快照读。

　　Read Repeatable隔离级别：**开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读。**

### 快照读的实现方式：undolog和多版本并发控制MVCC



## 3、Schema与数据类型优化

### 数据类型

更小的通常更好

简单就好

避免NULL

- 整数类型 UNSIGNED 性能相同。指定宽度没什么意义。
- 实数类型 
- 字符串类型 VARCHAR 仅使用必要空间 CHAR 定长
- 日期和时间 DATETIME TIMESTAMP 

### 设计陷阱

- 太多列
- ...

### alter table

会锁表。

## 4、索引

索引是存储引擎用于快速找到记录的一种数据结构。

### 索引基础

#### 类型

