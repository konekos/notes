# 1、final 语义

final 可以修饰变量、类、方法

## 变量

### 成员变量

- 类变量（static修饰）：
  - 直接赋值（声明时赋值）
  - 在静态代码块里赋值
- 实例变量
  - 在构造器里面赋值（可以使用构造器参数的值，或指定其他值）
  - 在非静态块里赋值
  - 直接赋值

### 局部变量

当final修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。而对于引用类型变量而言，它仅仅保存的是一个引用，final只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的

## 方法

1. 父类的final方法是不能够被子类重写的

2. final方法是可以被重载的

## 类

当一个类被final修饰时，表名该类是不能被子类继承的。



# 2. final的例子

final经常会被用作不变类上，利用final的不可更改性。我们先来看看什么是不变类。

> 不变类 

不变类的意思是创建该类的实例后，该实例的实例变量是不可改变的。满足以下条件则可以成为不可变类：

1. 使用private和final修饰符来修饰该类的成员变量
2. 提供带参的构造器用于初始化类的成员变量；
3. 仅为该类的成员变量提供getter方法，不提供setter方法，因为普通方法无法修改fina修饰的成员变量；
4. 如果有必要就重写Object类 的hashCode()和equals()方法，应该保证用equals()判断相同的两个对象其Hashcode值也是相等的。

JDK中提供的八个包装类和String类都是不可变类，我们来看看String的实现。

```
/** The value is used for character storage. */
 private final char value[];
```

可以看出String的value就是final修饰的，上述其他几条性质也是吻合的。

> 关于final重排序的总结

按照final修饰的数据类型分类：

基本数据类型:

1. final域写：禁止**final域写**与**构造方法**重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。
2. final域读：禁止初次**读对象的引用**与**读该对象包含的final域**的重排序。

引用数据类型：

额外增加约束：禁止在构造函数对**一个final修饰的对象的成员域的写入**与随后将**这个被构造的对象的引用赋值给引用变量** 重排序

# volitile

volitile保证原子性条件。

1. **运算结果并不依赖于变量的当前值，|或者|能够确保只有一个线程修改变量的值（多个只set也可以）；**
2. **变量不需要与其他的状态变量共同参与不变约束**



